/*
//  Simple Base Library for C++ (libsimple-base)
//  Copyright (c) 2010-2013, Adam Rehn
//
//  ---
//
//  Checksum Calculation Functions
//
//  The functions here wrap around third party implementations of checksum
//  functions for use with files and arbitrary data.
//
//  ---
//
//  This file is part of the Simple Base Library for C++ (libsimple-base).
//
//  libsimple-base is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published
//  by the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with libsimple-base. If not, see <http://www.gnu.org/licenses/>.
*/
#include "checksum.h"

#include "endianness.h"
#include "binary_manipulation.h"

#include <stdexcept>

//SHA-1 implementation by Paul E. Jones <paulej@packetizer.com>
#include "sha1.h"

//CRC32 implementation generated by pycrc
#include "crc32.h"

//Function Definitions for CRC32
uint32_t crc32(const string& path)
{
	ifstream infile(path.c_str(), ios::binary);
	if (infile.is_open())
	{
		return crc32(infile);
	}
	
	return 0;
}

uint32_t crc32(ifstream& infile)
{
	if (infile.is_open())
	{
		crc_t crc = crc_init();
		char buffer[512*1024];
		
		size_t bytesRead = 0;
		while ( (bytesRead = infile.read(buffer, sizeof(buffer)).gcount()) != 0 )
		{
			crc = crc32_cumulative(crc, buffer, bytesRead);
		}
		
		return crc_finalize(crc);
	}
	
	return 0;
}

uint32_t crc32(const char *data, unsigned int length)
{
	crc_t crc = crc_init();
	crc = crc_update(crc, (unsigned char*)data, length);
	return (unsigned int)crc_finalize(crc);
}

uint32_t crc32_cumulative(unsigned int crc, char* data, unsigned int length)
{
	crc_t result = crc;
	
	//If no data is supplied, we are simply initialising the checksum
	if (data == NULL)
	{
		//Initialise the checksum
		result = crc_init();
	}
	else
	{
		//Calculate the new checksum
		result = crc_update(crc, (unsigned char*)data, length);
	}
	
	return result;
}

//Function Definitions for SHA-1
string sha1(const string& data)
{
	//Call the other version of this function
	return sha1(data.data(), data.length());
}

string sha1(const char *data, int length)
{
	//The variables needed to use SHA-1
	SHA1 sha;
	unsigned int message_digest[5];
	
	//Input the data
	sha.Input(data, length);
	
	//Calculate the digest
	if (!sha.Result(message_digest))
	{
		//The digest couldn't be calculated
		return "";
	}
	else
	{
		//SHA-1 is big-endian, so for little-endian systems, flip the endianness
		if (endianness() == LITTLE_ENDIAN)
		{
			for (int i = 0; i < 5; ++i) {
				message_digest[i] = flipEndianness(message_digest[i]);
			}
		}
		
		//The digest was successfully calculated, so now we return the hex string of it
		return bin_to_hex(message_digest);
	}
}

string sha1_file(const string& file)
{
	//Allocate memory to hold the checksum
	unsigned int checksum_bytes[5];
	
	//Calculate the checksum
	sha1_file_raw(file, checksum_bytes);
	
	//Return the checksum
	return bin_to_hex(checksum_bytes);
}

//Generate the raw binary SHA-1 checksum for a file
void sha1_file_raw(const string& file, unsigned int checksum[5])
{
	//Attempt to open the specified file
	ifstream infile(file.c_str(), ios::binary);
	
	//Check that the file opened properly
	if (infile.is_open())
	{
		sha1_file_raw(infile, checksum);
		infile.close();
	}
	else {
		throw std::runtime_error("Couldn't open file!");
	}
}

void sha1_file_raw(ifstream& infile, unsigned int checksum[5])
{
	//Check that the file opened properly
	if (infile.is_open())
	{
		//Create a SHA-1 instance to calculate the checksum
		SHA1 chcksum;
		
		//Read the data
		char buffer[512*1024];
		unsigned int bytesRead = 0;
		while ( (bytesRead = infile.read(buffer, sizeof(buffer)).gcount()) != 0 )
		{
			//Add the contents of the buffer to the checksum
			chcksum.Input(buffer, bytesRead);
		}
		
		//Calculate the checksum
		if (!chcksum.Result(checksum)) {
			throw "Couldn't compute checksum!";
		}
		
		//SHA-1 is big-endian, so for little-endian systems, flip the endianness
		if (endianness() == LITTLE_ENDIAN)
		{
			for (int i = 0; i < 5; ++i) {
				checksum[i] = flipEndianness(checksum[i]);
			}
		}
	}
	else {
		throw std::runtime_error("File stream not open!");
	}
}
